@startuml
skinparam monochrome true
actor Пользователь as User

participant "JavaFX клиент" as Client
participant "REST API"       as API
participant "Spring Security" as Security
participant "Сервисы бизнес-логики" as Service
participant "Spring Cache"    as Cache
participant "Spring Data JPA" as DataLayer
participant "PostgreSQL"      as DB
participant "OpenAI API"      as AI
participant "WebSocket"       as WS

== 1. Авторизация ==
User -> Client: Ввести логин и пароль  
Client -> API: Отправить данные для входа  
API -> Security: Проверить учётные данные  
Security --> API: Учётные данные верны  
API -> Service: Запросить выпуск токена  
Service --> API: Вернуть JWT-токен  
API --> Client: Передать токен  
Client -> WS: Открыть WebSocket с токеном  
WS --> Client: Подключение установлено  

== 2. Создание или редактирование модели ==
User -> Client: Выбрать создание или открытие модели  
Client -> API: Отправить модельные данные и токен  
API -> Security: Проверить токен доступа  
Security --> API: Токен валиден  
API -> Service: Сохранить или обновить модель  
Service -> DataLayer: Записать модель в базу  
DataLayer -> DB: Выполнить INSERT/UPDATE  
DB --> DataLayer: Подтвердить операцию  
DataLayer --> Service: Вернуть сохранённую модель  
Service --> API: Отправить данные модели  
API --> Client: Показать форму модели  

== 3. Запуск вычислений ==
User -> Client: Запустить расчёты с параметрами  
Client -> API: Отправить параметры для расчёта  
API -> Security: Проверить токен  
Security --> API: Токен валиден  
API -> Service: Начать процесс вычисления  
Service -> Cache: Проверить кэш на наличие результата  
alt Результат в кеше найден
  Cache --> Service: Вернуть кешированный результат
else Результат не найден
  Service -> DataLayer: Загрузить модель из БД  
  DataLayer -> DB: SELECT  
  DB --> DataLayer: Данные модели  
  DataLayer --> Service: Модель загружена  

  Service -> Service: Выполнить вычисления  
  Service -> Cache: Сохранить результат в кэше  
end  
Service --> API: Отправить результаты вычислений  
API --> Client: Отобразить графики  
API -> WS: Отправить уведомление о готовности  
WS --> Client: Показать уведомление  

== 4. Сравнение с реальными данными ==
User -> Client: Перейти на экран сравнения  
Client -> API: Запросить сравнение для модели  
API -> Security: Проверить токен  
Security --> API: Токен валиден  
API -> Service: Подготовить данные для сравнения  
Service -> DataLayer: Загрузить расчёты и отчёт из БД  
DataLayer -> DB: SELECT расчёт, отчёт  
DB --> DataLayer: Данные получены  
DataLayer --> Service: Передать идеальные и реальные данные  

Service -> AI: Отправить отчёт на анализ  
AI --> Service: Вернуть извлечённые реальные показатели  
Service -> Service: Объединить идеальные и реальные данные  
Service --> API: Отправить готовое сравнение  
API --> Client: Показать таблицу и график сравнения  

== 5. Управление сохранёнными отчётами ==
User -> Client: Открыть список сохранённых отчётов  
Client -> API: Запросить список отчётов  
API -> Security: Проверить токен  
Security --> API: Токен валиден  
API -> Service: Получить список отчётов пользователя  
Service -> DataLayer: Загрузить записи из БД  
DataLayer -> DB: SELECT  
DB --> DataLayer: Список отчётов  
DataLayer --> Service: Передать список отчётов  
Service --> API: Вернуть список отчётов  
API --> Client: Отобразить список  

User -> Client: Скачать или удалить отчёт  
alt Скачать
  Client -> API: Запросить файл отчёта  
  API -> Service: Найти файл в хранилище  
  Service -> DataLayer: Получить метаданные  
  Service --> API: Вернуть файл  
  API --> Client: Начать загрузку файла  
else Удалить
  Client -> API: Отправить список ID для удаления  
  API -> Service: Удалить отчёты  
  Service -> DataLayer: Удалить записи из БД  
  DataLayer -> DB: DELETE  
  DB --> DataLayer: Подтверждение удаления  
  DataLayer --> Service: Отчёты удалены  
  Service --> API: Подтвердить удаление  
  API --> Client: Обновить список отчётов  
end

@enduml
